import os
import pytest
import tempfile
import logging
from unittest import mock
from typing import List, Generator
from src.scanner import run_vulnerability_scan, parse_bandit_results

# Configuração do logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

@pytest.fixture(scope="module")
def temp_directory() -> Generator[str, None, None]:
    """Fixture que cria e limpa um diretório temporário."""
    with tempfile.TemporaryDirectory() as temp_dir:
        logger.info(f"Diretório temporário criado em {temp_dir}")
        yield temp_dir
        logger.info(f"Diretório temporário {temp_dir} foi removido")

@pytest.fixture(scope="module")
def vulnerable_project(temp_directory: str) -> str:
    """Fixture que cria um projeto temporário com vulnerabilidades conhecidas."""
    vulnerable_file = os.path.join(temp_directory, "vulnerable.py")
    with open(vulnerable_file, "w") as f:
        f.write("import os\nos.system('rm -rf /')\n")
    logger.info(f"Projeto vulnerável criado em {temp_directory}")
    return temp_directory

@pytest.fixture(scope="module")
def safe_project(temp_directory: str) -> str:
    """Fixture que cria um projeto temporário sem vulnerabilidades."""
    safe_file = os.path.join(temp_directory, "safe.py")
    with open(safe_file, "w") as f:
        f.write("print('Hello, World!')\n")
    logger.info(f"Projeto seguro criado em {temp_directory}")
    return temp_directory

@pytest.mark.parametrize("project_fixture,expected", [
    ("temp_directory", []),
    ("safe_project", []),
    ("vulnerable_project", ["os.system"])
])
def test_run_vulnerability_scan(project_fixture: str, expected: List[str], request: pytest.FixtureRequest) -> None:
    """Testa o escaneamento de diferentes tipos de projetos."""
    project_path = request.getfixturevalue(project_fixture)
    result = run_vulnerability_scan(project_path)
    assert all(any(exp in r for r in result) for exp in expected), f"Resultado inesperado para {project_fixture}: {result}"

def test_scan_with_mocked_bandit(safe_project: str) -> None:
    """Testa o scanner com a execução do Bandit mockada."""
    with mock.patch('src.scanner.BanditManager.run_tests') as mocked_run_tests:
        mocked_run_tests.return_value = None
        result = run_vulnerability_scan(safe_project)
        assert mocked_run_tests.called, "BanditManager.run_tests deveria ter sido chamado."
        assert result == [], "Esperava uma lista vazia para projeto seguro com Bandit mockado."

def test_parse_bandit_results() -> None:
    """Testa a função de parsing dos resultados do Bandit."""
    raw_result = [
        {'filename': 'vulnerable.py', 'line_number': 1, 'issue_text': 'os.system call'},
    ]
    parsed_result = parse_bandit_results(raw_result)
    assert len(parsed_result) == 1, "Esperava que um único resultado fosse retornado."
    assert 'os.system' in parsed_result[0], "Esperava que o resultado contivesse 'os.system'."

def test_logging_functionality(caplog) -> None:
    """Testa se o logging está funcionando corretamente durante a execução."""
    with caplog.at_level(logging.INFO):
        run_vulnerability_scan('some_directory')
    assert "Scanning directory" in caplog.text, "Esperava uma mensagem de log sobre o início do scan."

def test_error_handling_for_invalid_directory() -> None:
    """Testa o tratamento de erro ao escanear um diretório inválido."""
    invalid_dir = "/invalid/directory/path"
    with pytest.raises(FileNotFoundError, match="No such file or directory"):
        run_vulnerability_scan(invalid_dir)

@pytest.mark.parametrize("num_files,file_size", [
    (1000, 10**3),  # 1000 arquivos de 1KB
    (500, 10**6),   # 500 arquivos de 1MB
])
def test_performance_large_codebase(num_files: int, file_size: int) -> None:
    """Testa a performance do scanner em uma base de código grande."""
    large_codebase_dir = tempfile.mkdtemp()
    try:
        for i in range(num_files):
            with open(os.path.join(large_codebase_dir, f"file_{i}.py"), "wb") as f:
                f.write(b"A" * file_size)
        result = run_vulnerability_scan(large_codebase_dir)
        assert isinstance(result, list), "Esperava uma lista de resultados."
    finally:
        for file in os.listdir(large_codebase_dir):
            os.remove(os.path.join(large_codebase_dir, file))
        os.rmdir(large_codebase_dir)

@pytest.mark.parametrize("file_size", [10**7, 10**8])  # 10MB e 100MB
def test_handling_of_large_files(file_size: int) -> None:
    """Testa o tratamento de arquivos grandes pelo scanner."""
    large_file_dir = tempfile.mkdtemp()
    try:
        large_file = os.path.join(large_file_dir, "large_file.py")
        with open(large_file, "wb") as f:
            f.write(b"A" * file_size)
        result = run_vulnerability_scan(large_file_dir)
        assert isinstance(result, list), "Esperava uma lista de resultados."
    finally:
        os.remove(large_file)
        os.rmdir(large_file_dir)

def test_code_compliance_with_pep8() -> None:
    """Verifica a conformidade do código com o estilo PEP8."""
    result = os.system("flake8 src/")
    assert result == 0, "Esperava que o código estivesse em conformidade com PEP8."

def test_type_hints_compliance() -> None:
    """Verifica se o código está utilizando type hints corretamente."""
    result = os.system("mypy src/")
    assert result == 0, "Esperava que o código estivesse em conformidade com type hints."
